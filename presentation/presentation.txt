
1. 팀 소개
2. 목차
    1. 왜 이 주제를 선정하였는가
    2. 무엇을 배우는가
    3. 어떻게 배우는가

첫번째는 저희 팀이 어떻게 주제를 선정하게 되었는지에 대해 말씀드리겠습니다. 
저희들은 inner-circle 과제들을 통해 운영체제에 대한 내용들을 같이 배울 수 있었습니다.

예를들면 get_next_line은 file system, 
pipex와 minitalk은 프로세스를 다루는 Inter process communication, 
philosophers에서는 프로세스 동기화와 관련된 mutex, semaphore, dead lock등의 지식을 얻어갈 수 있습니다.
하지만 앞선 과제들에서는 명시적으로 메모리 관리에 대한 주제는 없었습니다!
그래서 저희는 에듀톤의 취지에 맞추어 메모리 관리 중 page replacement algorithm에 대해 Dash를 제작해 보았습니다.

---

두번째로 무엇을 배울지,
저희가 만든 과제를 통해 먼저 메인 메모리에 페이징 개념이 적용되는 방법, 페이징, 페이지 교체 알고리즘이 필요한 경우와 종류에 대해 말씀드리겠습니다.

오른쪽 그림을 봐주세요! 

사용자가 볼 수 있는 논리 메모리는 page 단위이며, 
실제 메인(물리) 메모리는 frame단위로 나뉩니다. 

현재 프로세스가 논리 메모리에서 메인메모리로 올리는데, 메인메모리에 올라간 프로세스의 페이지는 반드시 연속적으로 할당된다는 보장이 없습니다.

이때 운영체제는 메인 메모리에 접근하기 위해 페이지 테이블을 참조하여 논리 메모리의 주소를 물리 메모리의 주소로 변환합니다. 이를 페이징이라 부르며, 페이징을 통해 필요한 페이지만 메인메모리에 로드할 수 있습니다. 

하지만 오직 필요한 페이지만 메모리에 올려놓으면 메모리에 적재되지 않은 페이지에 접근하려 하는 순간 참조할 수 없게 되고 이를 page fault라고 합니다.

page fault가 발생하면 새로운 페이지를 메모리에 올리기 위해 메모리에서 탈락시킬 희생자(vicitim)페이지를 선택해야합니다. 희생자 페이지는 페이지 교체 알고리즘이 결정합니다.

희생자 페이지를 결정하는 페이지 교체 알고리즘의 종류에 대해 간략하게 설명하겠습니다.
FIFO - 가장 먼저 들어온 페이지를 희생자로
LRU - 가장 과거에 참조된 페이지를 희생자로
LFU - 가장 조금 참조된 페이지를 희생자로
OPT - 앞으로 가장 오랫동안 참조되지 않을 페이지를 희생자로 (항상 최선의 결과 보장)

---

마지막으로 저희가 제작한 과제를 통해 어떻게 배울 수 있는지에 대해 말씀드리겠습니다.
저희 서브젝트는 page fault가 가장 적게 일어나는 알고리즘을 구현하는 것이 목표이며, 
이를 위해 서브젝트에 제공된 페이지 교체 알고리즘 위키피디아 주소와, 
어떤 알고리즘이 가장 적절한 알고리즘일지 고민해보는 시간을 가질 수 있습니다.

과제에 직접 명시한 사항대로 구현하고, 제공된 테스터기인 corrector와 테스트 케이스를 돌려 볼 수 있는 test_cake.sh를 통해 자신이 구현한 알고리즘과 최적의 알고리즘인 optimal algorithm이 얼마나 일치헸는지 비교할 수 있습니다. 

서브젝트는 git repo에 올린 pdf를 참고해주세요.

Mandatory part를 완성하고 나면, 최적의 알고리즘은 미래의 프로세스 상태를 예측할 수 있어야만 구현이 가능한 알고리즘이라 실제로 사용되기에는 매우 어렵다는 것을 알 수 있습니다.
그래서 저희는 이 과제의 bonus로 미래를 예측할 필요 없이 실현 가능한 페이지 교체 알고리즘을 구현하도록 설정하였습니다.

저희가 만든 mandatory의 코드로 테스트케이스를 직접 돌려본 후 발표를 마치겠습니다!

(실행...)

주어진 테스터기와 함께 동료평가를 진행할 때 각자 공부한 여러 알고리즘들에 대해 이야기를 나눌 수 있다면 좋겠습니당
이만 차팀의 페이징 알고리즘 발표였습니다 감사합니다!

